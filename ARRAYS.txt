                                                      ARRAYS: Build Array from Permutation

Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.

A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive).

 SOLUTION:
class Solution {
    public int[] buildArray(int[] nums) {
        int [] ans = new int [nums.length];
        for(int i=0;i<nums.length;i++){
            ans[i] = nums[nums[i]];
        }
        return ans;
    }
}

						ARRAYS: Concatenation of Array
Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n (0-indexed).

Specifically, ans is the concatenation of two nums arrays.

Return the array ans

class Solution {
    public int[] getConcatenation(int[] nums) {
        int [] ans = new int[2*nums.length];
        for(int i = 0;i<nums.length;i++){
            ans[i]=nums[i];
            ans[nums.length+i] = nums[i];
        }
        return ans;
    }
}

						ARRAYS:Running Sum of 1d Array
Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).

Return the running sum of nums.

class Solution {
    public int[] runningSum(int[] nums) {
        int [] runsum = new int[nums.length];
        for(int i=0;i<nums.length;i++){
            int sum = 0;
            for(int j=0;j<=i;j++){
                sum+=nums[j];
            }
            runsum[i]=sum;
            sum=0;
        }
        return runsum;
    }
}

						ARRAYS: Richest Customer Wealth
You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.

A customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.

class Solution {
    public int maximumWealth(int[][] accounts) {
        int[] sums = new int[accounts.length];
        for(int i=0;i<accounts.length;i++){
            int sum = 0;
            for(int num:accounts[i]){
                sum+=num;
            }
            sums[i]=sum;
        }
        int max = sums[0];
        for(int i=0;i<sums.length;i++){
            if(sums[i]>max)
                max = sums[i];
        }
        return max;
    }
}

						ARRAYS: Shuffle the Array
Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].

Return the array in the form [x1,y1,x2,y2,...,xn,yn].

class Solution {
    public int[] shuffle(int[] nums, int n) {
        int [] ans = new int[nums.length];
        int j = 0;
        for(int i=0;i<n;i++){
            ans[j]=nums[i];
            ans[j+1]=nums[n+i];
            j+=2;
        }
        return ans;
    }
}

						Arrays:Kids With the Greatest Number of Candies
There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have.

Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise.

Note that multiple kids can have the greatest number of candies.

class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        ArrayList<Boolean> ans = new ArrayList<Boolean>();
        int max = candies[0];
    for(int i=0 ; i<candies.length ; i++){
        if(max<candies[i])
            max = candies[i];
    }
    for(int j=0; j<candies.length;j++){
        if(candies[j]+extraCandies>=max)
            ans.add(true);
        else
            ans.add(false);
    }
    return ans;
    }
}

						ARRAYS: Number of Good Pairs
Given an array of integers nums, return the number of good pairs.

A pair (i, j) is called good if nums[i] == nums[j] and i < j.

class Solution {
    public int numIdenticalPairs(int[] nums) {
        int count = 0;
        for(int i=0;i<nums.length-1;i++){
            for(int j=i+1;j<nums.length;j++){
                if(nums[i]==nums[j] && i<j){
                    count+=1;
                }
            }
        }
        return count;
    }
}

						ARRAYS: How Many Numbers Are Smaller Than the Current Number

Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].

Return the answer in an array.

class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int[] ans = new int[nums.length];
        for(int i=0;i<nums.length;i++){
            int count=0;
            for(int j=0;j<nums.length;j++){
                if(nums[i]>nums[j]){
                    count++;
                }
            }
            ans[i]=count;
        }
        return ans;
    }
}

					ARRAYS: Create Target Array in the Given Order
Given two arrays of integers nums and index. Your task is to create target array under the following rules:

Initially target array is empty.
From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array.
Repeat the previous step until there are no elements to read in nums and index.
Return the target array.

It is guaranteed that the insertion operations will be valid.

